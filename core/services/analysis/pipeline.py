# -*- coding: utf-8 -*-
"""
股票分析主流程调度器

从main.py迁移的StockAnalysisPipeline类
"""

import logging

# 导入依赖
import sys
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import date
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

project_root = Path(__file__).parent.parent.parent.parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from common.config import Config, get_config
from common.enums import ReportType
from core.domain.analysis import AnalysisResult
from core.domain.user import UserConfig
from core.services.notification import NotificationService
from core.services.notification.channels.base import NotificationChannel
from core.services.search import SearchService
from infrastructure.ai import STOCK_NAME_MAP, GeminiAnalyzer
from infrastructure.data import get_db
from infrastructure.fetchers import AkshareFetcher, ChipDistribution, DataFetcherManager, RealtimeQuote

from .trend_analyzer import StockTrendAnalyzer, TrendAnalysisResult

logger = logging.getLogger(__name__)


class StockAnalysisPipeline:
    """
    股票分析主流程调度器

    职责：
    1. 管理整个分析流程
    2. 协调数据获取、存储、搜索、分析、通知等模块
    3. 实现并发控制和异常处理
    """

    def __init__(
        self, config: Optional[Config] = None, max_workers: Optional[int] = None, user_config: UserConfig = None
    ):
        """
        初始化调度器

        Args:
            config: 配置对象（可选，默认使用全局配置，用于AI、数据源等共享配置）
            max_workers: 最大并发线程数（可选，默认从配置读取）
            user_config: 用户配置（必需）
        """
        if user_config is None:
            raise ValueError("user_config 参数是必需的，请传入 UserConfig 对象")

        self.config = config or get_config()
        self.max_workers = max_workers or self.config.max_workers
        self.user_config = user_config

        # 初始化各模块
        self.db = get_db()
        self.fetcher_manager = DataFetcherManager()
        self.akshare_fetcher = AkshareFetcher()  # 用于获取增强数据（量比、筹码等）
        self.trend_analyzer = StockTrendAnalyzer()  # 趋势分析器
        self.analyzer = GeminiAnalyzer()
        self.notifier = NotificationService(user_config=user_config)  # 使用用户专属的通知服务

        # 初始化搜索服务
        self.search_service = SearchService(
            bocha_keys=self.config.bocha_api_keys,
            tavily_keys=self.config.tavily_api_keys,
            serpapi_keys=self.config.serpapi_keys,
        )

        logger.info(f"调度器初始化完成，最大并发数: {self.max_workers}")
        logger.info("已启用趋势分析器 (MA5>MA10>MA20 多头判断)")
        if self.search_service.is_available:
            logger.info("搜索服务已启用 (Tavily/SerpAPI)")
        else:
            logger.warning("搜索服务未启用（未配置 API Key）")

    def fetch_and_save_stock_data(self, code: str, force_refresh: bool = False) -> Tuple[bool, Optional[str]]:
        """
        获取并保存单只股票数据

        断点续传逻辑：
        1. 检查数据库是否已有今日数据
        2. 如果有且不强制刷新，则跳过网络请求
        3. 否则从数据源获取并保存

        Args:
            code: 股票代码
            force_refresh: 是否强制刷新（忽略本地缓存）

        Returns:
            Tuple[是否成功, 错误信息]
        """
        try:
            today = date.today()

            # 断点续传检查：如果今日数据已存在，跳过
            if not force_refresh and self.db.has_today_data(code, today):
                logger.info(f"[{code}] 今日数据已存在，跳过获取（断点续传）")
                return True, None

            # 从数据源获取数据
            logger.info(f"[{code}] 开始从数据源获取数据...")
            df, source_name = self.fetcher_manager.get_daily_data(code, days=30)

            if df is None or df.empty:
                return False, "获取数据为空"

            # 保存到数据库
            saved_count = self.db.save_daily_data(df, code, source_name)
            logger.info(f"[{code}] 数据保存成功（来源: {source_name}，新增 {saved_count} 条）")

            return True, None

        except Exception as e:
            error_msg = f"获取/保存数据失败: {str(e)}"
            logger.error(f"[{code}] {error_msg}")
            return False, error_msg

    def analyze_stock(self, code: str) -> Optional[AnalysisResult]:
        """
        分析单只股票（增强版：含量比、换手率、筹码分析、多维度情报）

        流程：
        1. 获取实时行情（量比、换手率）
        2. 获取筹码分布
        3. 进行趋势分析（基于交易理念）
        4. 多维度情报搜索（最新消息+风险排查+业绩预期）
        5. 从数据库获取分析上下文
        6. 调用 AI 进行综合分析

        Args:
            code: 股票代码

        Returns:
            AnalysisResult 或 None（如果分析失败）
        """
        try:
            # 获取股票名称（优先从实时行情获取真实名称）
            stock_name = STOCK_NAME_MAP.get(code, "")

            # Step 1: 获取实时行情（量比、换手率等）
            realtime_quote: Optional[RealtimeQuote] = None
            try:
                realtime_quote = self.akshare_fetcher.get_realtime_quote(code)
                if realtime_quote:
                    # 使用实时行情返回的真实股票名称
                    if realtime_quote.name:
                        stock_name = realtime_quote.name
                    logger.info(
                        f"[{code}] {stock_name} 实时行情: 价格={realtime_quote.price}, "
                        f"量比={realtime_quote.volume_ratio}, 换手率={realtime_quote.turnover_rate}%"
                    )
            except Exception as e:
                logger.warning(f"[{code}] 获取实时行情失败: {e}")

            # 如果还是没有名称，使用代码作为名称
            if not stock_name:
                stock_name = f"股票{code}"

            # Step 2: 获取筹码分布
            chip_data: Optional[ChipDistribution] = None
            try:
                chip_data = self.akshare_fetcher.get_chip_distribution(code)
                if chip_data:
                    logger.info(
                        f"[{code}] 筹码分布: 获利比例={chip_data.profit_ratio:.1%}, "
                        f"90%集中度={chip_data.concentration_90:.2%}"
                    )
            except Exception as e:
                logger.warning(f"[{code}] 获取筹码分布失败: {e}")

            # Step 3: 趋势分析（基于交易理念）
            trend_result: Optional[TrendAnalysisResult] = None
            try:
                # 获取历史数据进行趋势分析
                context = self.db.get_analysis_context(code)
                if context and "raw_data" in context:
                    import pandas as pd

                    raw_data = context["raw_data"]
                    if isinstance(raw_data, list) and len(raw_data) > 0:
                        df = pd.DataFrame(raw_data)
                        trend_result = self.trend_analyzer.analyze(df, code)
                        logger.info(
                            f"[{code}] 趋势分析: {trend_result.trend_status.value}, "
                            f"买入信号={trend_result.buy_signal.value}, 评分={trend_result.signal_score}"
                        )
            except Exception as e:
                logger.warning(f"[{code}] 趋势分析失败: {e}")

            # Step 4: 多维度情报搜索（最新消息+风险排查+业绩预期）
            news_context = None
            if self.search_service.is_available:
                logger.info(f"[{code}] 开始多维度情报搜索...")

                # 使用多维度搜索（最多3次搜索）
                intel_results = self.search_service.search_comprehensive_intel(
                    stock_code=code, stock_name=stock_name, max_searches=3
                )

                # 格式化情报报告
                if intel_results:
                    news_context = self.search_service.format_intel_report(intel_results, stock_name)
                    total_results = sum(len(r.results) for r in intel_results.values() if r.success)
                    logger.info(f"[{code}] 情报搜索完成: 共 {total_results} 条结果")
                    logger.debug(f"[{code}] 情报搜索结果:\n{news_context}")
            else:
                logger.info(f"[{code}] 搜索服务不可用，跳过情报搜索")

            # Step 5: 获取分析上下文（技术面数据）
            context = self.db.get_analysis_context(code)

            if context is None:
                logger.warning(f"[{code}] 无法获取分析上下文，跳过分析")
                return None

            # Step 6: 增强上下文数据（添加实时行情、筹码、趋势分析结果、股票名称）
            enhanced_context = self._enhance_context(
                context, realtime_quote, chip_data, trend_result, stock_name  # 传入股票名称
            )

            # Step 7: 调用 AI 分析（传入增强的上下文和新闻）
            result = self.analyzer.analyze(enhanced_context, news_context=news_context)

            return result

        except Exception as e:
            logger.error(f"[{code}] 分析失败: {e}")
            logger.exception(f"[{code}] 详细错误信息:")
            return None

    def _enhance_context(
        self,
        context: Dict[str, Any],
        realtime_quote: Optional[RealtimeQuote],
        chip_data: Optional[ChipDistribution],
        trend_result: Optional[TrendAnalysisResult],
        stock_name: str = "",
    ) -> Dict[str, Any]:
        """
        增强分析上下文

        将实时行情、筹码分布、趋势分析结果、股票名称添加到上下文中

        Args:
            context: 原始上下文
            realtime_quote: 实时行情数据
            chip_data: 筹码分布数据
            trend_result: 趋势分析结果
            stock_name: 股票名称

        Returns:
            增强后的上下文
        """
        enhanced = context.copy()

        # 添加股票名称
        if stock_name:
            enhanced["stock_name"] = stock_name
        elif realtime_quote and realtime_quote.name:
            enhanced["stock_name"] = realtime_quote.name

        # 添加实时行情
        if realtime_quote:
            enhanced["realtime"] = {
                "name": realtime_quote.name,  # 股票名称
                "price": realtime_quote.price,
                "volume_ratio": realtime_quote.volume_ratio,
                "volume_ratio_desc": self._describe_volume_ratio(realtime_quote.volume_ratio),
                "turnover_rate": realtime_quote.turnover_rate,
                "pe_ratio": realtime_quote.pe_ratio,
                "pb_ratio": realtime_quote.pb_ratio,
                "total_mv": realtime_quote.total_mv,
                "circ_mv": realtime_quote.circ_mv,
                "change_60d": realtime_quote.change_60d,
            }

        # 添加筹码分布
        if chip_data:
            current_price = realtime_quote.price if realtime_quote else 0
            enhanced["chip"] = {
                "profit_ratio": chip_data.profit_ratio,
                "avg_cost": chip_data.avg_cost,
                "concentration_90": chip_data.concentration_90,
                "concentration_70": chip_data.concentration_70,
                "chip_status": chip_data.get_chip_status(current_price),
            }

        # 添加趋势分析结果
        if trend_result:
            enhanced["trend_analysis"] = {
                "trend_status": trend_result.trend_status.value,
                "ma_alignment": trend_result.ma_alignment,
                "trend_strength": trend_result.trend_strength,
                "bias_ma5": trend_result.bias_ma5,
                "bias_ma10": trend_result.bias_ma10,
                "volume_status": trend_result.volume_status.value,
                "volume_trend": trend_result.volume_trend,
                "buy_signal": trend_result.buy_signal.value,
                "signal_score": trend_result.signal_score,
                "signal_reasons": trend_result.signal_reasons,
                "risk_factors": trend_result.risk_factors,
            }

        return enhanced

    def _describe_volume_ratio(self, volume_ratio: float) -> str:
        """
        量比描述

        量比 = 当前成交量 / 过去5日平均成交量
        """
        if volume_ratio < 0.5:
            return "极度萎缩"
        elif volume_ratio < 0.8:
            return "明显萎缩"
        elif volume_ratio < 1.2:
            return "正常"
        elif volume_ratio < 2.0:
            return "温和放量"
        elif volume_ratio < 3.0:
            return "明显放量"
        else:
            return "巨量"

    def process_single_stock(
        self,
        code: str,
        skip_analysis: bool = False,
        single_stock_notify: bool = False,
        report_type: ReportType = ReportType.SIMPLE,
    ) -> Optional[AnalysisResult]:
        """
        处理单只股票的完整流程

        包括：
        1. 获取数据
        2. 保存数据
        3. AI 分析
        4. 单股推送（可选，#55）

        此方法会被线程池调用，需要处理好异常

        Args:
            code: 股票代码
            skip_analysis: 是否跳过 AI 分析
            single_stock_notify: 是否启用单股推送模式（每分析完一只立即推送）
            report_type: 报告类型枚举

        Returns:
            AnalysisResult 或 None
        """
        logger.info(f"========== 开始处理 {code} ==========")

        try:
            # Step 1: 获取并保存数据
            success, error = self.fetch_and_save_stock_data(code)

            if not success:
                logger.warning(f"[{code}] 数据获取失败: {error}")
                # 即使获取失败，也尝试用已有数据分析

            # Step 2: AI 分析
            if skip_analysis:
                logger.info(f"[{code}] 跳过 AI 分析（dry-run 模式）")
                return None

            result = self.analyze_stock(code)

            if result:
                logger.info(f"[{code}] 分析完成: {result.operation_advice}, " f"评分 {result.sentiment_score}")

                # 单股推送模式（#55）：每分析完一只股票立即推送
                if single_stock_notify and self.notifier.is_available():
                    try:
                        # 根据报告类型选择生成方法
                        if report_type == ReportType.FULL:
                            # 完整报告：使用决策仪表盘格式
                            report_content = self.notifier.generate_dashboard_report([result])
                            logger.info(f"[{code}] 使用完整报告格式")
                        else:
                            # 精简报告：使用单股报告格式（默认）
                            report_content = self.notifier.generate_single_stock_report(result)
                            logger.info(f"[{code}] 使用精简报告格式")

                        if self.notifier.send(report_content):
                            logger.info(f"[{code}] 单股推送成功")
                        else:
                            logger.warning(f"[{code}] 单股推送失败")
                    except Exception as e:
                        logger.error(f"[{code}] 单股推送异常: {e}")

            return result

        except Exception as e:
            # 捕获所有异常，确保单股失败不影响整体
            logger.exception(f"[{code}] 处理过程发生未知异常: {e}")
            return None

    def process_gold(
        self,
        code: str = "AU",
        skip_analysis: bool = False,
        single_stock_notify: bool = False,
        report_type: ReportType = ReportType.SIMPLE,
    ) -> Optional[AnalysisResult]:
        """
        处理黄金分析的完整流程

        流程：
        1. 获取黄金数据
        2. 保存数据
        3. 搜索黄金相关资讯
        4. AI分析
        5. 生成报告

        Args:
            code: 黄金代码（默认 "AU"）
            skip_analysis: 是否跳过 AI 分析
            single_stock_notify: 是否启用单股推送模式
            report_type: 报告类型枚举

        Returns:
            AnalysisResult 或 None
        """
        logger.info(f"========== 开始处理黄金 {code} ==========")

        try:
            # Step 1: 获取并保存黄金数据
            success, error = self.fetch_and_save_stock_data(code)  # 复用现有方法，DataFetcherManager 会自动识别 AU

            if not success:
                logger.warning(f"[{code}] 黄金数据获取失败: {error}")
                # 即使获取失败，也尝试用已有数据分析

            # Step 2: AI 分析
            if skip_analysis:
                logger.info(f"[{code}] 跳过 AI 分析（dry-run 模式）")
                return None

            result = self.analyze_gold(code)

            if result:
                logger.info(f"[{code}] 黄金分析完成: {result.operation_advice}, " f"评分 {result.sentiment_score}")

                # 单股推送模式：每分析完立即推送
                if single_stock_notify and self.notifier.is_available():
                    try:
                        if report_type == ReportType.FULL:
                            report_content = self.notifier.generate_dashboard_report([result])
                            logger.info(f"[{code}] 使用完整报告格式")
                        else:
                            report_content = self.notifier.generate_single_stock_report(result)
                            logger.info(f"[{code}] 使用精简报告格式")

                        if self.notifier.send(report_content):
                            logger.info(f"[{code}] 黄金单股推送成功")
                        else:
                            logger.warning(f"[{code}] 黄金单股推送失败")
                    except Exception as e:
                        logger.error(f"[{code}] 黄金单股推送异常: {e}")

            return result

        except Exception as e:
            logger.exception(f"[{code}] 黄金处理过程发生未知异常: {e}")
            return None

    def analyze_gold(self, code: str = "AU") -> Optional[AnalysisResult]:
        """
        分析黄金

        流程：
        1. 进行趋势分析（基于交易理念）
        2. 搜索黄金相关资讯（美联储政策、通胀数据、地缘政治等）
        3. 从数据库获取分析上下文
        4. 调用 AI 进行综合分析

        Args:
            code: 黄金代码（"AU"）

        Returns:
            AnalysisResult 或 None（如果分析失败）
        """
        try:
            gold_name = "黄金"

            # Step 1: 趋势分析（基于交易理念）
            trend_result: Optional[TrendAnalysisResult] = None
            try:
                # 获取历史数据进行趋势分析
                context = self.db.get_analysis_context(code)
                if context and "raw_data" in context:
                    import pandas as pd

                    raw_data = context["raw_data"]
                    if isinstance(raw_data, list) and len(raw_data) > 0:
                        df = pd.DataFrame(raw_data)
                        trend_result = self.trend_analyzer.analyze(df, code)
                        logger.info(
                            f"[{code}] 黄金趋势分析: {trend_result.trend_status.value}, "
                            f"买入信号={trend_result.buy_signal.value}, 评分={trend_result.signal_score}"
                        )
            except Exception as e:
                logger.warning(f"[{code}] 黄金趋势分析失败: {e}")

            # Step 2: 搜索黄金相关资讯
            news_context = None
            if self.search_service.is_available:
                logger.info(f"[{code}] 开始搜索黄金相关资讯...")

                # 使用专门的黄金情报搜索方法
                try:
                    intel_results = self.search_service.search_gold_intel(max_searches=3)

                    if intel_results:
                        news_context = self.search_service.format_intel_report(intel_results, gold_name)
                        total_results = sum(len(r.results) for r in intel_results.values() if r.success)
                        logger.info(f"[{code}] 黄金情报搜索完成: 共 {total_results} 条结果")
                        logger.debug(f"[{code}] 黄金情报搜索结果:\n{news_context}")
                except Exception as e:
                    logger.warning(f"[{code}] 黄金情报搜索失败: {e}")
            else:
                logger.info(f"[{code}] 搜索服务不可用，跳过黄金情报搜索")

            # Step 3: 获取分析上下文（技术面数据）
            context = self.db.get_analysis_context(code)

            if context is None:
                logger.warning(f"[{code}] 无法获取黄金分析上下文，跳过分析")
                return None

            # Step 4: 增强上下文数据（添加趋势分析结果、黄金名称）
            enhanced_context = self._enhance_gold_context(context, trend_result, gold_name)

            # Step 5: 调用 AI 分析（传入增强的上下文和新闻）
            # 注意：这里需要调用专门的黄金分析方法
            result = self.analyzer.analyze_gold(enhanced_context, news_context=news_context)

            return result

        except Exception as e:
            logger.error(f"[{code}] 黄金分析失败: {e}")
            logger.exception(f"[{code}] 详细错误信息:")
            return None

    def _enhance_gold_context(
        self,
        context: Dict[str, Any],
        trend_result: Optional[TrendAnalysisResult],
        gold_name: str = "黄金",
    ) -> Dict[str, Any]:
        """
        增强黄金分析上下文

        将趋势分析结果、黄金名称添加到上下文中

        Args:
            context: 原始上下文
            trend_result: 趋势分析结果
            gold_name: 黄金名称

        Returns:
            增强后的上下文
        """
        enhanced = context.copy()

        # 添加黄金名称
        enhanced["gold_name"] = gold_name
        enhanced["asset_type"] = "gold"

        # 添加趋势分析结果
        if trend_result:
            enhanced["trend_analysis"] = {
                "trend_status": trend_result.trend_status.value,
                "ma_alignment": trend_result.ma_alignment,
                "trend_strength": trend_result.trend_strength,
                "bias_ma5": trend_result.bias_ma5,
                "bias_ma10": trend_result.bias_ma10,
                "volume_status": trend_result.volume_status.value,
                "volume_trend": trend_result.volume_trend,
                "buy_signal": trend_result.buy_signal.value,
                "signal_score": trend_result.signal_score,
                "signal_reasons": trend_result.signal_reasons,
                "risk_factors": trend_result.risk_factors,
            }

        return enhanced

    def run(
        self,
        stock_codes: Optional[List[str]] = None,
        dry_run: bool = False,
        send_notification: bool = True,
        asset_type_filter: Optional[str] = None,
    ) -> List[AnalysisResult]:
        """
        运行完整的分析流程

        流程：
        1. 获取待分析的资产列表（股票+黄金）
        2. 根据资产类型过滤
        3. 使用线程池并发处理
        4. 收集分析结果
        5. 发送通知

        Args:
            stock_codes: 资产代码列表（可选，默认使用配置中的自选股）
            dry_run: 是否仅获取数据不分析
            send_notification: 是否发送推送通知
            asset_type_filter: 资产类型过滤，可选 "stock", "gold", None(全部)

        Returns:
            分析结果列表
        """
        start_time = time.time()

        # 解析资产列表（区分股票和黄金）
        if stock_codes is None:
            # 使用用户配置中的资产列表
            assets = self.user_config.get_asset_list()
        else:
            # 从命令行参数解析资产类型
            assets = []
            for code in stock_codes:
                code_upper = code.strip().upper()
                if code_upper == "AU":
                    assets.append((code.strip(), "gold"))
                else:
                    assets.append((code.strip(), "stock"))

        # 如果指定了资产类型过滤，只处理对应类型
        if asset_type_filter:
            assets = [(code, atype) for code, atype in assets if atype == asset_type_filter]

        if not assets:
            asset_type_msg = f"（类型: {asset_type_filter}）" if asset_type_filter else ""
            logger.error(f"未配置资产列表{asset_type_msg}，请在配置中设置")
            return []

        # 统计资产类型
        stock_count = sum(1 for _, atype in assets if atype == "stock")
        gold_count = sum(1 for _, atype in assets if atype == "gold")

        logger.info(f"===== 开始分析 {len(assets)} 个资产 =====")
        logger.info(f"股票: {stock_count} 只, 黄金: {gold_count} 个")
        logger.info(f"资产列表: {', '.join([f'{code}({atype})' for code, atype in assets])}")
        logger.info(f"并发数: {self.max_workers}, 模式: {'仅获取数据' if dry_run else '完整分析'}")

        # 单股推送模式（#55）：从配置读取
        single_stock_notify = getattr(self.config, "single_stock_notify", False)
        if single_stock_notify:
            logger.info("已启用单股推送模式：每分析完一个资产立即推送")

        results: List[AnalysisResult] = []

        # 使用线程池并发处理
        # 注意：max_workers 设置较低（默认3）以避免触发反爬
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # 提交任务
            future_to_asset = {}
            for code, asset_type in assets:
                if asset_type == "gold":
                    future = executor.submit(
                        self.process_gold,
                        code,
                        skip_analysis=dry_run,
                        single_stock_notify=single_stock_notify and send_notification,
                    )
                else:
                    future = executor.submit(
                        self.process_single_stock,
                        code,
                        skip_analysis=dry_run,
                        single_stock_notify=single_stock_notify and send_notification,
                    )
                future_to_asset[future] = (code, asset_type)

            # 收集结果
            for future in as_completed(future_to_asset):
                code, asset_type = future_to_asset[future]
                try:
                    result = future.result()
                    if result:
                        results.append(result)
                except Exception as e:
                    logger.error(f"[{code}({asset_type})] 任务执行失败: {e}")

        # 统计
        elapsed_time = time.time() - start_time

        # dry-run 模式下，数据获取成功即视为成功
        if dry_run:
            # 检查哪些资产的数据今天已存在
            success_count = sum(1 for code, _ in assets if self.db.has_today_data(code))
            fail_count = len(assets) - success_count
        else:
            success_count = len(results)
            fail_count = len(assets) - success_count

        logger.info(f"===== 分析完成 =====")
        logger.info(f"成功: {success_count}, 失败: {fail_count}, 耗时: {elapsed_time:.2f} 秒")

        # 发送通知（单股推送模式下跳过汇总推送，避免重复）
        if results and send_notification and not dry_run:
            if single_stock_notify:
                # 单股推送模式：只保存汇总报告，不再重复推送
                logger.info("单股推送模式：跳过汇总推送，仅保存报告到本地")
                self._send_notifications(results, skip_push=True)
            else:
                self._send_notifications(results)

        return results

    def _send_notifications(self, results: List[AnalysisResult], skip_push: bool = False) -> None:
        """
        发送分析结果通知

        生成决策仪表盘格式的报告

        Args:
            results: 分析结果列表
            skip_push: 是否跳过推送（仅保存到本地，用于单股推送模式）
        """
        try:
            logger.info("生成决策仪表盘日报...")

            # 生成决策仪表盘格式的详细日报
            report = self.notifier.generate_dashboard_report(results)

            # 保存到本地
            filepath = self.notifier.save_report_to_file(report)
            logger.info(f"决策仪表盘日报已保存: {filepath}")

            # 跳过推送（单股推送模式）
            if skip_push:
                return

            # 推送通知
            if self.notifier.is_available():
                channels = self.notifier.get_available_channels()

                # 企业微信：只发精简版（平台限制）
                wechat_success = False
                if NotificationChannel.WECHAT in channels:
                    dashboard_content = self.notifier.generate_wechat_dashboard(results)
                    logger.info(f"企业微信仪表盘长度: {len(dashboard_content)} 字符")
                    logger.debug(f"企业微信推送内容:\n{dashboard_content}")
                    wechat_success = self.notifier.send_to_wechat(dashboard_content)

                # 其他渠道：发完整报告（避免自定义 Webhook 被 wechat 截断逻辑污染）
                non_wechat_success = False
                non_wechat_channels = [ch for ch in channels if ch != NotificationChannel.WECHAT]
                if non_wechat_channels:
                    non_wechat_success = self.notifier.send(report)

                success = wechat_success or non_wechat_success
                if success:
                    logger.info("决策仪表盘推送成功")
                else:
                    logger.warning("决策仪表盘推送失败")
            else:
                logger.info("通知渠道未配置，跳过推送")

        except Exception as e:
            logger.error(f"发送通知失败: {e}")
